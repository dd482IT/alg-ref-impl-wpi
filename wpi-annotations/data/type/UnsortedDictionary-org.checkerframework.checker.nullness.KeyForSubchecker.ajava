package dev.thinke.domain.data.type;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.KeyForSubchecker")
public abstract class UnsortedDictionary<K extends Comparable<K>, V> implements PriorityQueue<K, V> {

    /**
     * O(n)
     * Must potentially compare against every element (sequential search)
     * @param key
     * @return
     */
    @org.checkerframework.dataflow.qual.Pure
    public V search( UnsortedDictionary<K, V> this, K key) {
        return null;
    }

    /**
     * O(1)
     * Insertion index doesn't matter, just add to the end and increment n
     * @param key
     * @param value
     */
    @org.checkerframework.dataflow.qual.Pure
    public void insert( UnsortedDictionary<K, V> this, K key, V value) {
    }

    /**
     * O(n)
     * The book says this is constant time, but only because the parameter is a reference to the element to remove
     * If the parameter is just a key, as in this case, you must first search for the removal index (O(n))
     * Most unsorted implementations use a linked list, however, so once you find the index, removal is constant
     * @param key
     */
    @org.checkerframework.dataflow.qual.Pure
    public void delete( UnsortedDictionary<K, V> this, K key) {
    }

    /**
     * O(n)
     * @return
     */
    @org.checkerframework.dataflow.qual.Pure
    public V max( UnsortedDictionary<K, V> this) {
        return null;
    }

    /**
     * O(n)
     * @return
     */
    @org.checkerframework.dataflow.qual.Pure
    public V min( UnsortedDictionary<K, V> this) {
        return null;
    }

    /**
     * O(n)
     * @return
     */
    @org.checkerframework.dataflow.qual.Pure
    public V previous( UnsortedDictionary<K, V> this, K key) {
        return null;
    }

    /**
     * O(n)
     * @return
     */
    @org.checkerframework.dataflow.qual.Pure
    public V next( UnsortedDictionary<K, V> this, K key) {
        return null;
    }
}
