package dev.thinke.domain.sort.alg.heap;

import dev.thinke.domain.sort.alg.Index;
import dev.thinke.domain.sort.type.InPlace;
import java.util.ArrayList;
import java.util.List;

@org.checkerframework.framework.qual.AnnotatedFor(
    "org.checkerframework.checker.nullness.KeyForSubchecker")
public class MinHeap<T extends Comparable<T>>
    implements PriorityQueue<T>, BinaryTree<T>, InPlace<T> {

  private final Index<T> items;

  private Integer n;

  public MinHeap(final Integer size) {
    this.items = new Index<>(new ArrayList<>(size));
    this.n = size;
  }

  public MinHeap(final List<T> items) {
    this.items = new Index<>(new ArrayList<>(items.size()));
    this.n = 0;
    items.forEach(this::insert);
  }

  public void insert(MinHeap<T> this, T element) {
    items.add(element);
    this.n++;
    bubbleUp(lastIndex());
  }

  public T extractMin(MinHeap<T> this) {
    if (this.n > 0) {
      T item = items.retrieveFirst();
      items.assign(firstIndex(), items.retrieve(lastIndex()));
      items.assign(lastIndex(), null);
      this.n--;
      bubbleDown(firstIndex());
      return item;
    } else {
      return null;
    }
  }

  public T parent(MinHeap<T> this, Integer k) {
    final var parentI = parentIndex(k);
    if (parentI.equals(-1)) {
      return null;
    }
    return items.retrieve(parentI);
  }

  // young child
  public T leftChild(MinHeap<T> this, Integer k) {
    return items.retrieve(leftChildIndex(k));
  }

  public T rightChild(MinHeap<T> this, Integer k) {
    return items.retrieve(rightChildIndex(k));
  }

  public List<T> sort(MinHeap<T> this, List<T> original) {
    for (int i = 0; i < original.size(); i++) {
      original.set(i, extractMin());
    }
    return original;
  }

  // since parents should be less than their children in a min-heap, swap if parent is greater than
  // k
  // then repeat for the new item at the parent index (now k)
  // hence we bubble up to the top of the heap, the most minimum element
  private void bubbleUp(MinHeap<T> this, Integer k) {
    final T parent = parent(k);
    if (parent == null) {
      return;
    }
    if (parent.compareTo(items.retrieve(k)) > 0) {
      final var parentI = parentIndex(k);
      items.swap(k, parentI);
      bubbleUp(parentI);
    }
  }

  // since parents should be less than their children in a min-heap
  // when we replace an element not on the bottom level, we should compare it to its children
  // if it doesn't dominate both of them, we swap it with the most minimum of the two and continue
  // down
  private void bubbleDown(MinHeap<T> this, Integer k) {
    int child = leftChildIndex(k);
    var minChild = k;
    for (int i = 0; i <= 1; i++) {
      if ((child + i) <= this.n) {
        if (items.retrieve(minChild).compareTo(items.retrieve(child + i)) > 0) {
          minChild = child + i;
        }
      }
    }
    if (!minChild.equals(k)) {
      items.swap(k, minChild);
      bubbleDown(minChild);
    }
  }

  @org.checkerframework.dataflow.qual.Pure
  private Integer firstIndex(MinHeap<T> this) {
    return 1;
  }

  @org.checkerframework.dataflow.qual.Pure
  private Integer lastIndex(MinHeap<T> this) {
    return this.n;
  }

  @org.checkerframework.dataflow.qual.Pure
  private Integer parentIndex(MinHeap<T> this, final Integer k) {
    if (k == 1) {
      return -1;
    }
    return k / 2;
  }

  @org.checkerframework.dataflow.qual.Pure
  private Integer leftChildIndex(MinHeap<T> this, final Integer k) {
    return k * 2;
  }

  @org.checkerframework.dataflow.qual.Pure
  private Integer rightChildIndex(MinHeap<T> this, final Integer k) {
    return (k * 2) + 1;
  }
}
